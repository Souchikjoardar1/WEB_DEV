import { useState, useEffect } from "react";

function App() {
  // State to keep track of the currently active color
  const [activeColor, setActiveColor] = useState(null);
  
  // State to store the sequence of colors generated by the game
  const [sequence, setSequence] = useState([]);
  
  // State to store the sequence of colors input by the user
  const [userInput, setUserInput] = useState([]);
  
  // State to indicate whether the game has started
  const [gameStarted, setGameStarted] = useState(false);
  
  // State to store the message displayed to the user
  const [message, setMessage] = useState('Click "Start Game" to begin');
  
  // State to control the visibility of the game rules
  const [showRules, setShowRules] = useState(false);
  
  // State to store the result message after the game ends
  const [resultMessage, setResultMessage] = useState("");
  
  // State to control the visibility of the prompt
  const [showPrompt, setShowPrompt] = useState(false);
  
  // State to keep track of the count of each color in the sequence
  const [colorCount, setColorCount] = useState({});
  
  // State to set the length of the color sequence
  const [sequenceLength, setSequenceLength] = useState(2);

  // Array of possible colors in the game
  const colors = [
    "red",
    "orange",
    "yellow",
    "green",
    "blue",
    "indigo",
    "violet",
  ];

  // Function to toggle the active color and handle user input
  const toggleColor = (color) => {
    // Set the active color to the clicked color or null if it's already active
    setActiveColor((prevColor) => (prevColor === color ? null : color));
    
    // Change the background color of the document body to the active color
    document.body.style.backgroundColor = color;
    
    // If the game has started, add the color to the user's input sequence
    if (gameStarted) {
      setUserInput([...userInput, color]);
      
      // Update the count of the clicked color
      setColorCount((prevCount) => ({
        ...prevCount,
        [color]: (prevCount[color] || 0) + 1,
      }));
    }
  };

  const startGame = () => {
    // Set the game as started
    setGameStarted(true);
    // Update the message to instruct the user to watch the sequence
    setMessage("Watch the sequence");
    // Clear any previous result message
    setResultMessage("");
    // Generate a new sequence of colors
    const newSequence = generateSequence(sequenceLength);
    // Set the new sequence in state
    setSequence(newSequence);
    // Clear the user's input
    setUserInput([]);
    // Reset the color count
    setColorCount({});
    // Show the generated sequence to the user
    showSequence(newSequence);
  };

  const generateSequence = (length) => {
    const newSequence = [];
    // Generate a sequence of random colors of the specified length
    for (let i = 0; i < length; i++) {
      const randomColor = colors[Math.floor(Math.random() * colors.length)];
      newSequence.push(randomColor);
    }
    return newSequence;
  };

  const showSequence = (sequence) => {
    // Show each color in the sequence with a delay
    sequence.forEach((color, index) => {
      setTimeout(() => {
        // Set the active color
        setActiveColor(color);
        // Change the background color to the active color
        document.body.style.backgroundColor = color;
        setTimeout(() => {
          // Reset the active color
          setActiveColor(null);
          // Change the background color back to white
          document.body.style.backgroundColor = "white";
          // If this is the last color in the sequence, prompt the user to start their turn
          if (index === sequence.length - 1) {
            setMessage("Now it's your turn");
          }
        }, 500);
      }, index * 1000);
    });
  };

  useEffect(() => {
    // Check if the user's input matches the sequence when the input length matches the sequence length
    if (userInput.length === sequence.length && gameStarted) {
      if (JSON.stringify(userInput) === JSON.stringify(sequence)) {
        // If the input matches the sequence, the user wins
        setResultMessage("YOU WIN!");
      } else {
        // If the input does not match the sequence, the user loses
        setResultMessage("YOU LOSE!");
      }
      // End the game
      setGameStarted(false);
      // Reset the background color to white
      document.body.style.backgroundColor = "white";
      // Show the prompt to restart the game after a delay
      setTimeout(() => {
        setShowPrompt(true);
      }, 2000);
    }
  }, [userInput, sequence, gameStarted]);

  const toggleRules = () => {
    // Toggle the visibility of the game rules
    setShowRules(!showRules);
  };

  const handleRestart = (restart) => {
    // Hide the prompt
    setShowPrompt(false);
    if (restart) {
      // Increase the sequence length and start a new game
      setSequenceLength((prevLength) => Math.min(prevLength + 2, 4));
      startGame();
    } else {
      // Display the game over message
      setMessage("Game Over");
    }
  };

  return (
    <div>
      {/* Display the current message */}
      <div className="fixed flex flex-wrap justify-center bottom-12 inset-x-0 px-2">
        {message}
      </div>
      {/* Display the control buttons */}
      <div className="fixed bottom-0 inset-x-0 flex justify-center mb-4">
        <div className="flex flex-wrap justify-center gap-3 shadow-lg px-3 py-2">
          <div
            className="flex justify-center items-center p-4 rounded-lg"
            style={{
              background:
                "linear-gradient(to right, red, orange, yellow, green, blue, indigo, violet)",
            }}
          >
            {/* Start Game button */}
            <button
              onClick={startGame}
              className="outline-none px-4 py-2 mx-2 rounded-full text-white shadow-lg transition-transform transform hover:scale-105 hover:shadow-xl"
              style={{ backgroundColor: "black", minWidth: "80px" }}
            >
              Start Game
            </button>
            {/* Show Rules button */}
            <button
              onClick={toggleRules}
              className="outline-none px-4 py-2 mx-2 rounded-full text-white shadow-lg transition-transform transform hover:scale-105 hover:shadow-xl"
              style={{ backgroundColor: "gray", minWidth: "80px" }}
            >
              Show Rules
            </button>
            {/* Color buttons */}
            {colors.map((color) => (
              <button
                key={color}
                className={`outline-none px-4 py-2 mx-2 rounded-full text-white shadow-lg transition-transform transform hover:scale-105 hover:shadow-xl ${
                  activeColor === color ? "opacity-50" : ""
                }`}
                style={{ backgroundColor: color, minWidth: "80px" }}
                onClick={() => toggleColor(color)}
              >
                {color.charAt(0).toUpperCase() + color.slice(1)}
                {colorCount[color] > 1 && (
                  <span className="bubble">{colorCount[color]}</span>
                )}
              </button>
            ))}
          </div>
        </div>
      </div>
      {/* Display the game rules if showRules is true */}
      {showRules && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center">
          <div className="bg-white p-6 rounded-lg shadow-lg">
            <h2 className="text-2xl mb-4">Game Rules</h2>
            <div className="rules-container">
              <p className="rule">1. Click &quot;Start Game&quot; to begin.</p>
              <p className="rule">2. Watch the sequence of colors.</p>
              <p className="rule">3. Click the buttons in the same order.</p>
              <p className="rule">4. Match the sequence to win!</p>
            </div>
            <button
              onClick={toggleRules}
              className="outline-none px-4 py-2 rounded-full text-white shadow-lg transition-transform transform hover:scale-105 hover:shadow-xl"
              style={{ backgroundColor: "black" }}
            >
              OK
            </button>
          </div>
        </div>
      )}
      {/* Display the result message if resultMessage is not empty */}
      {resultMessage && (
        <div className="fixed inset-0 flex justify-center items-center">
          <div className="flash-message text-4xl font-bold">
            {resultMessage}
          </div>
        </div>
      )}
      {/* Display the restart prompt if showPrompt is true */}
      {showPrompt && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center">
          <div className="bg-white p-6 rounded-lg shadow-lg">
            <h2 className="text-2xl mb-4">Do you want to restart the game?</h2>
            <button
              onClick={() => handleRestart(true)}
              className="outline-none px-4 py-2 mx-2 rounded-full text-white shadow-lg transition-transform transform hover:scale-105 hover:shadow-xl"
              style={{ backgroundColor: "green" }}
            >
              Yes
            </button>
            <button
              onClick={() => handleRestart(false)}
              className="outline-none px-4 py-2 mx-2 rounded-full text-white shadow-lg transition-transform transform hover:scale-105 hover:shadow-xl"
              style={{ backgroundColor: "red" }}
            >
              No
            </button>
          </div>
        </div>
      )}
      <style>{`
        .rules-container {
          display: flex;
          flex-direction: column;
          align-items: center;
        }
        .rule {
          animation: fall 1s ease-in-out forwards;
        }
        // Apply animation delay to the first rule
        .rule:nth-child(1) {
          animation-delay: 0s;
        }
        // Apply animation delay to the second rule
        .rule:nth-child(2) {
          animation-delay: 0.5s;
        }
        // Apply animation delay to the third rule
        .rule:nth-child(3) {
          animation-delay: 1s;
        }
        // Apply animation delay to the fourth rule
        .rule:nth-child(4) {
          animation-delay: 1.5s;
        }
        // Define keyframes for the fall animation
        @keyframes fall {
          0% {
            transform: translateY(-100%); // Start above the viewport
            opacity: 0; // Start fully transparent
          }
          100% {
            transform: translateY(0); // End at the original position
            opacity: 1; // End fully opaque
          }
        }
        // Apply flash animation to elements with the flash-message class
        .flash-message {
          animation: flash 1s infinite;
        }
        // Define keyframes for the flash animation
        @keyframes flash {
          0%, 100% {
            opacity: 1; // Fully opaque at the start and end
          }
          50% {
            opacity: 0; // Fully transparent at the midpoint
          }
        }
        .bubble {
          position: absolute;
          top: -10px;
          right: -10px;
          background-color: white;
          color: black;
          border-radius: 50%;
          padding: 5px 10px;
          font-size: 12px;
        }
      `}</style>
    </div>
  );
}

export default App;
